{% schema %}
{
  "name": "Interactive Gallery",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Product Gallery"
    },
    {
      "type": "textarea",
      "id": "left_text",
      "label": "Left Side Text",
      "default": "NOT JUST ABOUT FORM & FUNCTION."
    },
    {
      "type": "range",
      "id": "image_count",
      "min": 6,
      "max": 25,
      "step": 1,
      "label": "Number of Products",
      "default": 15
    },
    {
      "type": "color",
      "id": "bg_color",
      "label": "Background Color",
      "default": "#ffffff"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text Color",
      "default": "#1f1f1f"
    },
    {
      "type": "color",
      "id": "icon_color",
      "label": "Corner Icon Color",
      "default": "#FF5733"
    }
  ],
  "blocks": [
    {
      "name": "Product",
      "type": "product",
      "settings": [
        {
          "type": "product",
          "id": "product",
          "label": "Product"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Interactive Gallery"
    }
  ]
}
{% endschema %}

<style>
  #interactive-gallery {
    background-color: {{ section.settings.bg_color }};
    color: {{ section.settings.text_color }};
    position: relative;
    z-index: 1;
  }

  #interactive-gallery * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  #interactive-gallery body,
  #interactive-gallery {
    background-color: {{ section.settings.bg_color }};
  }

  #interactive-gallery a,
  #interactive-gallery p {
    text-decoration: none;
    color: {{ section.settings.text_color }};
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: 15px;
    font-weight: 600;
    line-height: 1;
    letter-spacing: -0.02rem;
  }

  #interactive-gallery img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    backface-visibility: hidden;
    display: block;
    border-radius: 4px;
  }

  #interactive-gallery .gallery-section {
    position: relative;
    width: 100%;
    min-height: 100vh;
    display: flex;
    flex-direction: row;
    align-items: center;
    overflow: hidden;
  }

  #interactive-gallery .gallery-section.preview-active {
    overflow: visible;
  }

  #interactive-gallery .gallery-left {
    position: relative;
    width: 55%;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #interactive-gallery .gallery-right {
    position: relative;
    width: 45%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    padding: 0 5%;
  }

  #interactive-gallery .gallery-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    transform-style: preserve-3d;
    perspective: 2000px;
    will-change: transform;
  }

  #interactive-gallery .gallery {
    position: relative;
    width: 600px;
    height: 600px;
    display: flex;
    justify-content: center;
    align-items: center;
    transform-origin: center;
    will-change: transform;
  }

  #interactive-gallery .card {
    position: absolute;
    width: 50px;
    height: 67px;
    border-radius: 4px;
    transform-origin: center;
    will-change: transform;
    transform-style: preserve-3d;
    backface-visibility: visible;
    overflow: hidden;
    cursor: pointer;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    transition: box-shadow 0.3s ease;
    background-color: #ddd;
  }

  #interactive-gallery .card:hover {
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    transform: translateZ(10px) scale(1.05);
  }

  #interactive-gallery .card::after {
    content: attr(data-price);
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 100;
  }

  #interactive-gallery .card:hover::after {
    opacity: 1;
  }

  #interactive-gallery .title-container {
    position: fixed;
    bottom: 25%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 42px;
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    z-index: 10;
  }

  #interactive-gallery .title-container p {
    position: absolute;
    width: 100%;
    text-align: center;
    font-size: 36px;
    letter-spacing: -0.05rem;
    font-weight: 700;
  }

  #interactive-gallery .word {
    position: relative;
    display: inline-block;
    will-change: transform;
  }

  #interactive-gallery .discover-btn-container {
    position: fixed;
    bottom: 18%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    text-align: center;
  }

  #interactive-gallery .discover-btn {
    display: inline-block;
    padding: 12px 32px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: 13px;
    font-weight: 700;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: {{ section.settings.text_color }};
    background: transparent;
    border: none;
    cursor: pointer;
    text-decoration: none;
    transition: opacity 0.3s ease;
  }

  #interactive-gallery .discover-btn:hover {
    opacity: 0.6;
  }

  @media (max-width: 768px) {
    #interactive-gallery .discover-btn-container {
      bottom: 15%;
    }

    #interactive-gallery .discover-btn {
      font-size: 11px;
      padding: 10px 24px;
    }
  }


  #interactive-gallery .instructions {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    font-size: 12px;
    opacity: 0.7;
    z-index: 20;
    display: none;
  }

  #interactive-gallery .instructions p {
    margin: 2px 0;
    font-size: 12px;
  }

  #interactive-gallery .right-text {
    position: relative;
    max-width: 420px;
  }

  #interactive-gallery .right-text h2 {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: clamp(28px, 3.5vw, 48px);
    font-weight: 400;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    line-height: 1.25;
    color: {{ section.settings.text_color }};
    margin: 0 0 2rem 0;
  }

  #interactive-gallery .cta-btn {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    padding: 16px 36px;
    background-color: {{ section.settings.icon_color }};
    color: #ffffff;
    border: none;
    border-radius: 0;
    cursor: pointer;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: 13px;
    font-weight: 700;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    text-decoration: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 5;
  }

  #interactive-gallery .cta-btn:hover {
    opacity: 0.9;
    transform: scale(1.03);
  }

  #interactive-gallery .cta-btn svg {
    width: 20px;
    height: 20px;
    fill: white;
  }

  /* Mobile-only elements hidden on desktop */
  #interactive-gallery .mobile-text-top,
  #interactive-gallery .mobile-btn-bottom {
    display: none;
  }

  @media (max-width: 768px) {
    #interactive-gallery .gallery-section {
      flex-direction: column;
    }

    /* Hide desktop right panel on mobile */
    #interactive-gallery .gallery-right {
      display: none;
    }

    /* Show mobile text above gallery */
    #interactive-gallery .mobile-text-top {
      display: block;
      order: 1;
      width: 100%;
      text-align: center;
      padding: 8rem 1.5rem 1rem;
    }

    #interactive-gallery .mobile-text-top h2 {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 22px;
      font-weight: 400;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      line-height: 1.25;
      color: {{ section.settings.text_color }};
      margin: 0;
    }

    /* Gallery in the middle */
    #interactive-gallery .gallery-left {
      width: 100%;
      min-height: auto;
      order: 2;
      padding: 1rem 0;
    }

    /* Show mobile button below gallery */
    #interactive-gallery .mobile-btn-bottom {
      display: flex;
      justify-content: center;
      order: 3;
      width: 100%;
      padding: 3rem 1.5rem 2rem;
      position: relative;
      z-index: 1;
    }

    #interactive-gallery .gallery {
      width: 350px;
      height: 350px;
    }

    #interactive-gallery .card {
      width: 50px;
      height: 68px;
    }

    #interactive-gallery .title-container p {
      font-size: 24px;
    }

    #interactive-gallery .cta-btn {
      font-size: 11px;
      padding: 14px 28px;
    }
  }
</style>

<div id="interactive-gallery">
  <div class="gallery-section">
    <!-- Mobile: Text above gallery -->
    <div class="mobile-text-top">
      <h2>{{ section.settings.left_text }}</h2>
    </div>

    <!-- Left: Circular Gallery -->
    <div class="gallery-left">
      <div class="gallery-container">
        <div class="gallery" id="gallery"></div>
      </div>
    </div>

    <!-- Mobile: Button below gallery -->
    <div class="mobile-btn-bottom">
      <button class="cta-btn" id="mobile-corner-icon" title="Shuffle Products">
        DISCOVER OUR PRODUCTS
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
        </svg>
      </button>
    </div>

    <!-- Right: Text + CTA Button (desktop only) -->
    <div class="gallery-right">
      <div class="right-text" id="right-text">
        <h2>{{ section.settings.left_text }}</h2>
        <button class="cta-btn" id="corner-icon" title="Shuffle Products">
          DISCOVER OUR PRODUCTS
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="title-container" id="title-container"></div>
    <div class="discover-btn-container" id="discover-btn-container"></div>
    <div class="instructions">
      <p>Click to preview â€¢ Double-click to visit product</p>
      <p>{{ section.settings.image_count }} random products from your store</p>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const gallery = document.getElementById('gallery');
    const galleryContainer = document.querySelector('#interactive-gallery .gallery-container');
    const titleContainer = document.getElementById('title-container');
    const discoverContainer = document.getElementById('discover-btn-container');
    const rightText = document.querySelector('#interactive-gallery .right-text');
    const cornerIcon = document.getElementById('corner-icon');
    const mobileCornerIcon = document.getElementById('mobile-corner-icon');
    const mobileTextTop = document.querySelector('#interactive-gallery .mobile-text-top');
    const mobileBtnBottom = document.querySelector('#interactive-gallery .mobile-btn-bottom');

    // Generate colored SVG data URLs for guaranteed image display
    function generateColoredImage(index) {
      const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
        '#F8B500', '#00CED1', '#FF69B4', '#32CD32', '#FF7F50',
        '#6495ED', '#DC143C', '#00FA9A', '#FFD700', '#8A2BE2',
        '#FF4500', '#2E8B57', '#FF1493', '#00BFFF', '#9370DB'
      ];
      const color = colors[index % colors.length];
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><rect fill="${color}" width="200" height="200"/><text x="100" y="110" font-family="Arial" font-size="24" fill="white" text-anchor="middle">${index + 1}</text></svg>`;
      return 'data:image/svg+xml;base64,' + btoa(svg);
    }

    // Create products array with guaranteed images
    const products = [];
    const productCount = {{ section.settings.image_count }};
    
    for (let i = 0; i < productCount; i++) {
      products.push({
        title: `Product ${i + 1}`,
        image: generateColoredImage(i),
        id: `product-${i + 1}`,
        url: '#',
        price: `$${(Math.random() * 200 + 20).toFixed(2)}`,
        vendor: 'Store'
      });
    }

    // Load ALL Shopify products for shuffling (larger pool)
    const allShopifyProducts = [];
    {% for product in collections.all.products limit: 100 %}
      {% if product.featured_image %}
      allShopifyProducts.push({
        title: "{{ product.title | escape }}",
        image: "{{ product.featured_image | image_url: width: 300 }}",
        id: "{{ product.id }}",
        url: "{{ product.url }}",
        price: "{{ product.price | money }}",
        vendor: "{{ product.vendor | escape }}"
      });
      {% endif %}
    {% endfor %}

    // Shuffle all products to get random initial selection
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Use Shopify products if available, otherwise use generated fallbacks
    let finalProducts;
    let displayedProductIds = new Set(); // Track which products are currently displayed
    
    if (allShopifyProducts.length > 0) {
      // Shuffle and pick initial products
      const shuffledAll = shuffleArray(allShopifyProducts);
      finalProducts = shuffledAll.slice(0, Math.min(productCount, shuffledAll.length));
      finalProducts.forEach(p => displayedProductIds.add(p.id));
    } else {
      finalProducts = products;
    }
    
    // Ensure we have enough products (fill with generated if needed)
    while (finalProducts.length < productCount) {
      const idx = finalProducts.length;
      finalProducts.push({
        title: `Product ${idx + 1}`,
        image: generateColoredImage(idx),
        id: `product-${idx + 1}`,
        url: '#',
        price: `$${(Math.random() * 200 + 20).toFixed(2)}`,
        vendor: 'Store'
      });
    }

    console.log('All products available:', allShopifyProducts.length);
    console.log('Products displayed:', finalProducts.length);
    console.log('First product:', finalProducts[0]);
    
    const cards = [];
    const transformState = [];

    let currentTitle = null;
    let isPreviewActive = false;
    let isTransitioning = false;

    const config = {
      imageCount: finalProducts.length,
      radius: 275,
      sensitivity: 500,
      effectFalloff: 250,
      cardMoveAmount: 50,
      lerpFactor: 0.15,
      isMobile: window.innerWidth < 1000,
    };

    const parallaxState = {
      targetX: 0,
      targetY: 0,
      targetZ: 0,
      currentX: 0,
      currentY: 0,
      currentZ: 0,
    };

    // Create cards
    for (let i = 0; i < config.imageCount; i++) {
      const angle = (i / config.imageCount) * Math.PI * 2;
      const x = config.radius * Math.cos(angle);
      const y = config.radius * Math.sin(angle);
      const productIndex = i % finalProducts.length;
      const productData = finalProducts[productIndex];

      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.index = i;
      card.dataset.title = productData.title || `Product ${i + 1}`;
      card.dataset.price = productData.price || '$0.00';
      card.dataset.url = productData.url || '#';

      const img = document.createElement('img');
      img.src = productData.image || generateColoredImage(i);
      img.alt = productData.title || `Product ${i + 1}`;
      img.onerror = function() {
        this.src = generateColoredImage(i);
        this.onerror = null;
      };
      
      card.appendChild(img);

      gsap.set(card, {
        x,
        y,
        rotation: (angle * 180) / Math.PI + 90,
        transformPerspective: 800,
        transformOrigin: 'center center',
      });

      gallery.appendChild(card);
      cards.push(card);
      transformState.push({
        currentRotation: 0,
        targetRotation: 0,
        currentX: 0,
        targetX: 0,
        currentY: 0,
        targetY: 0,
        currentScale: 1,
        targetScale: 1,
        angle,
      });

      card.addEventListener('click', (e) => {
        if (!isPreviewActive && !isTransitioning) {
          const now = Date.now();
          const timeDiff = now - (card.lastClickTime || 0);
          
          if (timeDiff < 300 && productData.url && productData.url !== '#') {
            window.location.href = productData.url;
          } else {
            togglePreview(parseInt(card.dataset.index));
          }
          
          card.lastClickTime = now;
          e.stopPropagation();
        }
      });
    }

    function togglePreview(index) {
      isPreviewActive = true;
      isTransitioning = true;

      // Add preview-active class for overflow
      document.querySelector('#interactive-gallery .gallery-section').classList.add('preview-active');

      // Animate right text section out (desktop)
      gsap.to(rightText, {
        x: 200,
        opacity: 0,
        duration: 0.8,
        ease: 'power3.inOut'
      });

      // Animate mobile elements out
      if (mobileTextTop) {
        gsap.to(mobileTextTop, {
          y: -50,
          opacity: 0,
          duration: 0.8,
          ease: 'power3.inOut'
        });
      }
      if (mobileBtnBottom) {
        gsap.to(mobileBtnBottom, {
          y: 50,
          opacity: 0,
          duration: 0.8,
          ease: 'power3.inOut'
        });
      }

      // Calculate offset to center the gallery-left on the full viewport
      const galleryLeft = document.querySelector('#interactive-gallery .gallery-left');
      const galleryLeftRect = galleryLeft.getBoundingClientRect();
      const galleryCenterX = galleryLeftRect.left + galleryLeftRect.width / 2;
      const viewportCenterX = window.innerWidth / 2;
      const offsetX = viewportCenterX - galleryCenterX;

      // Animate gallery-left to slide to viewport center
      gsap.to(galleryLeft, {
        x: offsetX,
        duration: 2,
        ease: 'power4.inOut'
      });

      const angle = transformState[index].angle;
      const targetPosition = (Math.PI * 3) / 2;
      let rotationRadians = targetPosition - angle;

      if (rotationRadians > Math.PI) rotationRadians -= Math.PI * 2;
      else if (rotationRadians < -Math.PI) rotationRadians += Math.PI * 2;

      transformState.forEach((state) => {
        state.currentRotation = state.targetRotation = 0;
        state.currentScale = state.targetScale = 1;
        state.currentX = state.targetX = state.currentY = state.targetY = 0;
      });

      gsap.to(gallery, {
        onStart: () => {
          cards.forEach((card, i) => {
            gsap.to(card, {
              x: config.radius * Math.cos(transformState[i].angle),
              y: config.radius * Math.sin(transformState[i].angle),
              rotationY: 0,
              scale: 1,
              duration: 1.25,
              ease: 'power4.out',
            });
          });
        },
        scale: 5,
        y: 1300,
        rotation: (rotationRadians * 180) / Math.PI + 360,
        duration: 2,
        ease: 'power4.inOut',
        onComplete: () => (isTransitioning = false),
      });

      gsap.to(parallaxState, {
        currentX: 0,
        currentY: 0,
        currentZ: 0,
        duration: 0.5,
        ease: 'power2.out',
        onUpdate: () => {
          gsap.set(galleryContainer, {
            rotateX: parallaxState.currentX,
            rotateY: parallaxState.currentY,
            rotation: parallaxState.currentZ,
            transformOrigin: 'center center',
          });
        },
      });

      const titleText = cards[index].dataset.title;
      const p = document.createElement('p');
      p.textContent = titleText;
      titleContainer.appendChild(p);
      currentTitle = p;

      // Split text into words for animation
      const words = titleText.split(' ');
      const wordElements = [];
      p.innerHTML = words
        .map((word, i) => `<span class="word" style="display: inline-block; margin: 0 4px;">${word}</span>`)
        .join(' ');

      const wordSpans = p.querySelectorAll('.word');
      gsap.set(wordSpans, { y: '125%' });
      gsap.to(wordSpans, {
        y: '0%',
        duration: 0.75,
        delay: 1.25,
        stagger: 0.1,
        ease: 'power4.out',
      });

      // Add Discover button
      const productUrl = cards[index].dataset.url;
      discoverContainer.innerHTML = '';
      const discoverLink = document.createElement('a');
      discoverLink.className = 'discover-btn';
      discoverLink.href = productUrl && productUrl !== '#' ? productUrl : '#';
      discoverLink.textContent = 'DISCOVER';
      discoverLink.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!productUrl || productUrl === '#') {
          e.preventDefault();
        }
      });
      discoverContainer.appendChild(discoverLink);
      gsap.set(discoverLink, { opacity: 0, y: 15 });
      gsap.to(discoverLink, {
        opacity: 1,
        y: 0,
        duration: 0.6,
        delay: 1.8,
        ease: 'power3.out',
      });
    }

    function resetGallery() {
      if (isTransitioning) return;

      isTransitioning = true;

      if (currentTitle) {
        const words = currentTitle.querySelectorAll('.word');
        gsap.to(words, {
          y: '-125%',
          duration: 0.75,
          delay: 0.5,
          stagger: 0.1,
          ease: 'power4.out',
          onComplete: () => {
            currentTitle.remove();
            currentTitle = null;
          },
        });
      }

      // Animate discover button out
      const discoverBtn = discoverContainer.querySelector('.discover-btn');
      if (discoverBtn) {
        gsap.to(discoverBtn, {
          opacity: 0,
          y: 15,
          duration: 0.4,
          delay: 0.3,
          ease: 'power3.in',
          onComplete: () => {
            discoverContainer.innerHTML = '';
          },
        });
      }

      const viewportWidth = window.innerWidth;
      let galleryScale = 1;

      if (viewportWidth < 768) {
        galleryScale = 0.6;
      } else if (viewportWidth < 1200) {
        galleryScale = 0.8;
      }

      // Animate gallery-left back to original position
      const galleryLeft = document.querySelector('#interactive-gallery .gallery-left');
      gsap.to(galleryLeft, {
        x: 0,
        duration: 2.5,
        ease: 'power4.inOut'
      });

      gsap.to(gallery, {
        scale: galleryScale,
        y: 0,
        x: 0,
        rotation: 0,
        duration: 2.5,
        ease: 'power4.inOut',
        onComplete: () => {
          isPreviewActive = isTransitioning = false;
          document.querySelector('#interactive-gallery .gallery-section').classList.remove('preview-active');
          Object.assign(parallaxState, {
            targetX: 0,
            targetY: 0,
            targetZ: 0,
            currentX: 0,
            currentY: 0,
            currentZ: 0,
          });
        },
      });

      // Animate right text section back in (desktop)
      gsap.to(rightText, {
        x: 0,
        opacity: 1,
        duration: 1,
        delay: 1.5,
        ease: 'power3.out'
      });

      // Animate mobile elements back in
      if (mobileTextTop) {
        gsap.to(mobileTextTop, {
          y: 0,
          opacity: 1,
          duration: 1,
          delay: 1.5,
          ease: 'power3.out'
        });
      }
      if (mobileBtnBottom) {
        gsap.to(mobileBtnBottom, {
          y: 0,
          opacity: 1,
          duration: 1,
          delay: 1.8,
          ease: 'power3.out'
        });
      }
    }

    function handleResize() {
      const viewportWidth = window.innerWidth;
      config.isMobile = viewportWidth < 1000;

      let galleryScale = 1;

      if (viewportWidth < 768) {
        galleryScale = 0.6;
      } else if (viewportWidth < 1200) {
        galleryScale = 0.8;
      }

      gsap.set(gallery, {
        scale: galleryScale,
      });

      if (!isPreviewActive) {
        parallaxState.targetX = 0;
        parallaxState.targetY = 0;
        parallaxState.targetZ = 0;
        parallaxState.currentX = 0;
        parallaxState.currentY = 0;
        parallaxState.currentZ = 0;

        transformState.forEach((state) => {
          state.targetRotation = 0;
          state.currentRotation = 0;
          state.targetScale = 1;
          state.currentScale = 1;
          state.targetX = 0;
          state.currentX = 0;
          state.targetY = 0;
          state.currentY = 0;
        });
      }
    }

    window.addEventListener('resize', handleResize);
    handleResize();

    document.addEventListener('click', () => {
      if (isPreviewActive && !isTransitioning) {
        resetGallery();
      }
    });


    // Shuffle functionality - fetch NEW random products
    let isShuffling = false;
    
    function shuffleGallery() {
      if (isShuffling || isPreviewActive || isTransitioning) return;
      
      isShuffling = true;
      
      // Get products that are NOT currently displayed
      let availableForShuffle = allShopifyProducts.filter(p => !displayedProductIds.has(p.id));
      
      // If not enough new products available, allow reusing some products
      if (availableForShuffle.length < cards.length) {
        // Shuffle all products and use them
        availableForShuffle = shuffleArray(allShopifyProducts);
      } else {
        // Shuffle the available products
        availableForShuffle = shuffleArray(availableForShuffle);
      }
      
      // Select new products for the gallery
      const newProducts = availableForShuffle.slice(0, cards.length);
      
      // Update the displayed product IDs tracker
      displayedProductIds.clear();
      newProducts.forEach(p => displayedProductIds.add(p.id));
      
      // Update finalProducts array with new products
      newProducts.forEach((product, i) => {
        if (i < finalProducts.length) {
          finalProducts[i] = product;
        }
      });
      
      // Spin the gallery - starts fast, slows down smoothly
      const spinRotations = 2 + Math.random() * 1.5; // 2-3.5 full rotations
      
      gsap.to(gallery, {
        rotation: `+=${360 * spinRotations}`,
        duration: 2.2,
        ease: 'power3.out', // Smooth deceleration - fast start, slow end
        onUpdate: function() {
          // Get progress of the animation (0 to 1)
          const progress = this.progress();
          
          // Start updating products when rotation is 70% complete (slowing down phase)
          if (progress >= 0.7 && !this._shuffleStarted) {
            this._shuffleStarted = true;
            
            // Apply new products with staggered animation during slow-down
            cards.forEach((card, index) => {
              const newProduct = newProducts[index];
              if (!newProduct) return;
              
              const img = card.querySelector('img');
              
              gsap.to(card, {
                scale: 0.6,
                duration: 0.12,
                delay: index * 0.015,
                ease: 'power2.in',
                onComplete: () => {
                  // Update card with new product data
                  if (img) {
                    img.src = newProduct.image || generateColoredImage(index);
                    img.alt = newProduct.title || `Product ${index + 1}`;
                    img.onerror = function() {
                      this.src = generateColoredImage(index);
                      this.onerror = null;
                    };
                  }
                  
                  // Update card data attributes
                  card.dataset.title = newProduct.title || `Product ${index + 1}`;
                  card.dataset.price = newProduct.price || '$0.00';
                  card.dataset.url = newProduct.url || '#';
                  
                  gsap.to(card, {
                    scale: 1,
                    duration: 0.25,
                    ease: 'back.out(1.5)'
                  });
                }
              });
            });
          }
        },
        onComplete: () => {
          // Reset shuffling state after all animations complete
          setTimeout(() => {
            isShuffling = false;
          }, 500);
        }
      });
      
      // Animate the CTA button icon - synced with gallery
      const btnIcon = cornerIcon.querySelector('svg');
      if (btnIcon) {
        gsap.to(btnIcon, {
          rotation: '+=720',
          duration: 2.2,
          ease: 'power3.out'
        });
      }
    }
    
    cornerIcon.addEventListener('click', (e) => {
      e.stopPropagation();
      shuffleGallery();
    });

    if (mobileCornerIcon) {
      mobileCornerIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        shuffleGallery();
      });
    }

    // Interaction-heavy animation (parallax + hover flip + keyboard + mouse out)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isPreviewActive && !isTransitioning) {
        resetGallery();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isPreviewActive || isTransitioning || config.isMobile) return;

      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const percentX = (e.clientX - centerX) / centerX;
      const percentY = (e.clientY - centerY) / centerY;

      parallaxState.targetY = percentX * 15;
      parallaxState.targetX = -percentY * 15;
      parallaxState.targetZ = (percentX + percentY) * 5;

      cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        const dx = e.clientX - (rect.left + rect.width / 2);
        const dy = e.clientY - (rect.top + rect.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < config.sensitivity && !config.isMobile) {
          const flipFactor = Math.max(0, 1 - distance / config.effectFalloff);
          const angle = transformState[index].angle;
          const moveAmount = config.cardMoveAmount * flipFactor;

          transformState[index].targetRotation = 180 * flipFactor;
          transformState[index].targetScale = 1 + 0.3 * flipFactor;
          transformState[index].targetX = moveAmount * Math.cos(angle);
          transformState[index].targetY = moveAmount * Math.sin(angle);
        } else {
          transformState[index].targetRotation = 0;
          transformState[index].targetScale = 1;
          transformState[index].targetX = 0;
          transformState[index].targetY = 0;
        }
      });
    });

    document.addEventListener('mouseout', (e) => {
      if ((e.relatedTarget === null || e.relatedTarget.nodeName === 'HTML') && !isPreviewActive && !isTransitioning) {
        transformState.forEach((state) => {
          state.targetRotation = 0;
          state.targetScale = 1;
          state.targetX = 0;
          state.targetY = 0;
        });
        parallaxState.targetX = 0;
        parallaxState.targetY = 0;
        parallaxState.targetZ = 0;
      }
    });

    function animate() {
      if (!isPreviewActive && !isTransitioning) {
        parallaxState.currentX += (parallaxState.targetX - parallaxState.currentX) * config.lerpFactor;
        parallaxState.currentY += (parallaxState.targetY - parallaxState.currentY) * config.lerpFactor;
        parallaxState.currentZ += (parallaxState.targetZ - parallaxState.currentZ) * config.lerpFactor;

        gsap.set(galleryContainer, {
          rotateX: parallaxState.currentX,
          rotateY: parallaxState.currentY,
          rotation: parallaxState.currentZ,
          transformOrigin: 'center center',
        });

        cards.forEach((card, index) => {
          const state = transformState[index];

          state.currentRotation += (state.targetRotation - state.currentRotation) * config.lerpFactor;
          state.currentScale += (state.targetScale - state.currentScale) * config.lerpFactor;
          state.currentX += (state.targetX - state.currentX) * config.lerpFactor;
          state.currentY += (state.targetY - state.currentY) * config.lerpFactor;

          const angle = state.angle;
          const baseX = config.radius * Math.cos(angle);
          const baseY = config.radius * Math.sin(angle);

          gsap.set(card, {
            x: baseX + state.currentX,
            y: baseY + state.currentY,
            rotationY: state.currentRotation,
            scale: state.currentScale,
            rotation: (angle * 180) / Math.PI + 90,
            transformOrigin: 'center center',
            transformPerspective: 1000,
          });
        });
      }
      requestAnimationFrame(animate);
    }

    animate();
  });
</script>